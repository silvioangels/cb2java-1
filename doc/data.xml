<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd" [
    <!ENTITY cb2j-long "Copybook and Application Data to Java">
    <!ENTITY cb2j "Copy2Java">
    <!ENTITY pic "PICTURE">
]>
<chapter>
  <title>Working with Application Data</title>

  <para>The first thing that needs to be done in order to work with 
  application data is to create a new Copybook instance using the 
  CopybookParser class. To do this, supply an InputStream (or Reader) 
  to the parse method. This method also takes a String for the name. It 
  is recommended that you supply a unique name at this point but 
  it&apos;s not important exaclty what you use, just that it&apos;s 
  meaningful and hopefully unique.  See the <link>parser</link> 
  documentation for more detail.</para>

  <para>Once you have an instance of the Copybook class, you can create 
  a new Record with the createnew() method or you can create a Record 
  from existing data using one of the parse() methods.  There are two 
  versions of the parse method, one taking an InputStream and the other 
  taking a byte array.  One key setting to note at this point is the 
  encoding setting on the Copybook class.  If no action is taken to 
  modify this setting, it will default to the host system&apos;s 
  default encoding.  You can also set this encoding using the System 
  property cb2java.encoding or by creating a file on the class path 
  called copybook.props that contains a property named encoding.  
  Youmay also programmatically set the encoding on the Copybook 
  instance, overriding any other settings.  There is intentionally no 
  parse method that takes a String because conversion to String will 
  corrupt data in many cobol types in un-reversible ways and should be 
  avoided.</para>

  <para>Once you have created a Record object you can programmatically 
  browse it&apos;s tree and read or modify the data. Each node, 
  incluing the Record itself is an instance of the Data class. There 
  are two main types Of Data class, groups and values. Groups contain 
  other elements and cannot be modified directly. Values never contain 
  children and are modifiable. The Record is a special type of 
  GroupData that is always the root of the record tree.  The easiest 
  way to distinguish between groups and value objects is to call the 
  isLeaf() method.  A value is a &apos;leaf&apos; and a group is 
  not.</para>

  <para>Groups mainly have identity and children.  When working with 
  groups, the main action to be taken is to retrieve it&apos;s 
  children.  A group&apos;s children can contain values (leaves) and 
  other groups.</para>

  <para>There are currently four types of ValueData.</para>

  <para>
      <simplelist>
          <member>CharData</member>
          <member>IntegerData</member>
          <member>DecimalData</member>
          <member>FloatData</member>
      </simplelist>
  </para>

  <para>All leaf Data types have Object versions for retrieving and setting the 
  values.  In addition, all leaf Data objects take String values and attempt to 
  convert them to the proper type.</para>

  <para>The use of these should be fairly intuitive but the basic idea 
  is that any data associated numeric type that has no decimal portion 
  will be represented in an IntegerData. All other numeric types except 
  floating point types are represented in DecimalData.  Anything that 
  is not strictly numeric is represented in a CharData Binary types are 
  not currently supported.  Floating point types are not strictly decimal types 
  and have special rules.</para>
  
  <sect1>
      <title>CharData</title>
      <para>CharData objects are used to represent text data.  It consists of
      normal text data and is always described by an AlphaNumeric defintion
      object.  The validation rules for alphanumeric depend on the &pic; 
      clause and how it specifies which elements can be in what positions
      and the length of the element.  The 'natural' Java type for CharData
      is String</para>
  </sect1>
  <sect1>
      <title>IntegerData</title>
      <para>IntegerData objects represent numeric types that have no fraction
      part.  The validation for these types is that no fraction is included
      and the number of digits are within the range specified by the &pic;
      clause of the elements definition.  The 'natural' java type for 
      IntegerData is java.math.BigInteger</para>
  </sect1>
  <sect1>
      <title>DecimalData</title>
      <para>DecimalData objects are for numeric data types that do contain
      a fractional portion.  Validation rules for DecimalData are that
      both the fractional portion and the integer portion are within
      their respective ranges.  The 'natural' java type for 
      DecimalData is java.math.BigDecimal.</para>
  </sect1>
  <sect1>
      <title>FloatData</title>
      <para>FloatData objects are used to represent single and double precision
      floating point types.  Floating point is treated separately from other 
      numeric types because the fractional portion of a floating point number is 
      not decimal and the rules for validation are very different for floating
      point data.  Floating point validation requires that the number specified is
      exactly representable in floating point representation specified by its 
      defintion element.  Floating point representations are hardware specific
      in COBOL and not all numbers that can be represented on one platform can
      be represented on all other.  Java uses IEEE-754 floating point representation
      which presents a problem when data is in another form.  Because of this issue
      the 'natural' java type in cb2java is BigDecimal.  The reasoning is that all
      floating point types should be representable as decimal.  However, be aware that
      most BigDecimal values can not be converted exactly to floating point.  If the
      underlying representation is IEEE-754, float and double Java types (depending on
      the precision of the COBOL type) are absolutely safe to use and are generally
      preferrable.  It may also be possible to safely work with Java floats and doubles
      when the underlying data is not represented as IEEE-754 with careful management
      of the precision of the integer and (especially) the fraction portion.</para>
  </sect1>
      <title>Conclusion</title>
      <para>The four main types of Data are really the heart of the design behind
      the CB2Java project.  By 
  <sect1>
</chapter>